<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Extractor & Formatter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <style>
        .copy-btn.copied {
            background-color: #22c55e;
            color: white;
        }
        body {
            font-family: 'Inter', sans-serif;
        }
        .output-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
        }
         .output-item:last-child {
            border-bottom: none;
        }
        .output-label {
            font-weight: 600;
            margin-right: 0.5rem;
            white-space: nowrap;
        }
        .output-value {
            flex-grow: 1;
            text-align: left;
            word-break: break-word;
            margin-right: 0.5rem;
        }
        .output-value.needs-review {
            color: #f87171; /* Tailwind red-400 for dark mode */
        }
        .copy-btn {
            margin-left: 1rem;
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
            transition: background-color 0.2s ease, color 0.2s ease;
            flex-shrink: 0;
            border-radius: 0.375rem;
            cursor: pointer;
        }
        .filename-section {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            border-radius: 0.375rem;
        }
        #filenameOutput {
            flex-grow: 1;
            margin-right: 1rem;
        }
        #pageTitle {
            cursor: pointer;
            user-select: none;
        }
        #imageUploadLabel {
            cursor: pointer;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s ease;
            display: inline-block;
            text-align: center;
        }
        #imageInput {
            display: none;
        }
        .loader {
            border: 4px solid #4A5568;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .processing {
            opacity: 0.7;
            cursor: not-allowed;
        }
        #dropZone {
            border-radius: 0.5rem;
            padding: 1.5rem;
            text-align: center;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        #dropZone p {
            margin-bottom: 0.75rem;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body class="bg-slate-900 min-h-screen p-4 md:p-8 flex items-center justify-center transition-colors duration-300">
    <div class="bg-slate-800 p-6 md:p-8 rounded-lg shadow-lg w-full max-w-2xl relative transition-colors duration-300">

        <h1 id="pageTitle" class="text-2xl font-semibold mb-6 text-center text-slate-200" title="Click to reset form (or press Backspace outside inputs)">Data Extractor & Formatter</h1>

        <div class="mb-4 border-b border-slate-700">
            <nav class="-mb-px flex space-x-8" aria-label="Tabs">
            </nav>
        </div>

        <div class="mb-4">
            <label for="dataInput" class="block text-sm font-medium text-slate-300 mb-1">Paste your data here:</label>
            <div class="flex items-center space-x-2">
                <textarea id="dataInput" rows="6" class="flex-grow p-3 border border-slate-600 rounded-md shadow-sm focus:ring-indigo-400 focus:border-indigo-400 text-sm resize-y bg-slate-700 text-slate-100 placeholder-slate-400" placeholder="Example:&#10;SKU: DC-CTO-25&#10;Font Style: Snap ITC&#10;..."></textarea>
                <button id="pasteButton" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-400 dark:ring-offset-slate-800 transition duration-150 ease-in-out text-sm">Paste</button>
            </div>
        </div>

        <div class="my-4 flex items-center">
            <div class="flex-grow border-t border-slate-600"></div>
            <span class="flex-shrink mx-4 text-slate-400 text-sm">OR</span>
            <div class="flex-grow border-t border-slate-600"></div>
        </div>

        <div id="dropZone" class="mb-6 bg-slate-700 border-2 border-dashed border-slate-600 rounded-lg">
            <p class="text-sm text-slate-400">Drag & Drop an image here</p>
            <label for="imageInput" id="imageUploadLabel" class="bg-blue-600 hover:bg-blue-700 text-white">Choose Image</label>
            <input type="file" id="imageInput" accept="image/*">
            <span id="fileName" class="block text-sm text-slate-400 italic mt-2">No file chosen</span>
            <p class="text-xs text-slate-500 mt-1">Image text will be extracted on submit. Accuracy depends on image quality.</p>
        </div>


        <div class="flex justify-end mb-6">
            <button id="submitButton" class="px-5 py-2 bg-green-700 text-white rounded-md hover:bg-green-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-400 dark:ring-offset-slate-800 transition duration-150 ease-in-out font-medium flex items-center justify-center">
                <span>Submit</span>
                <div id="submitSpinner" class="loader hidden ml-2"></div>
            </button>
        </div>

        <div id="outputSection" class="space-y-4 hidden">
            <div>
                <h2 class="text-lg font-semibold mb-3 text-slate-200 border-b border-slate-700 pb-2">Extracted Information</h2>
                <div id="extractedInfo" class="space-y-1 bg-slate-700/50 p-4 rounded-md shadow-inner">
                </div>
            </div>

            <div>
                <h2 class="text-lg font-semibold mb-3 text-slate-200 border-b border-slate-700 pb-2">Generated Filename</h2>
                <div class="filename-section bg-slate-700/50">
                    <div id="filenameOutput" class="text-sm text-slate-200 break-words">
                    </div>
                    <button id="copyFilenameButton" class="copy-btn bg-slate-600 text-slate-200 hover:bg-slate-500">Copy</button>
                </div>
            </div>
        </div>

        <div id="messageBox" class="mt-4 text-center text-sm font-medium hidden"></div>

    </div>

    <script>
        const dataInput = document.getElementById('dataInput');
        const pasteButton = document.getElementById('pasteButton');
        const submitButton = document.getElementById('submitButton');
        const outputSection = document.getElementById('outputSection');
        const extractedInfoDiv = document.getElementById('extractedInfo');
        const filenameOutputDiv = document.getElementById('filenameOutput');
        const copyFilenameButton = document.getElementById('copyFilenameButton');
        const messageBox = document.getElementById('messageBox');
        const pageTitle = document.getElementById('pageTitle');
        const imageInput = document.getElementById('imageInput');
        const fileNameSpan = document.getElementById('fileName');
        const submitSpinner = document.getElementById('submitSpinner');
        const dropZone = document.getElementById('dropZone');

        let selectedFile = null;
        let hasProcessedOnce = false;

        function showMessage(text, isError = false, duration = 3000) {
            messageBox.textContent = text;
            messageBox.className = `mt-4 text-center text-sm font-medium ${isError ? 'text-red-400' : 'text-green-400'}`;
            messageBox.classList.remove('hidden');
            if (messageBox.timeoutId) {
                clearTimeout(messageBox.timeoutId);
            }
            messageBox.timeoutId = setTimeout(() => {
                messageBox.classList.add('hidden');
                messageBox.timeoutId = null;
            }, duration);
        }

        function showProcessingState(isProcessing) {
            if (isProcessing) {
                submitButton.disabled = true;
                submitButton.classList.add('processing');
                submitSpinner.classList.remove('hidden');
            } else {
                submitButton.disabled = false;
                submitButton.classList.remove('processing');
                submitSpinner.classList.add('hidden');
            }
        }

        async function copyToClipboard(textToCopy, buttonElement) {
            const text = String(textToCopy || '');
            if (!text) {
                showMessage('Nothing to copy.', true);
                return;
            }

            const originalButtonClasses = buttonElement.className;
            const originalText = buttonElement.textContent;

            buttonElement.textContent = 'Copied!';
            buttonElement.className = 'copy-btn copied'; 

            if (navigator.clipboard && window.isSecureContext) {
                try {
                    await navigator.clipboard.writeText(text);
                    if (buttonElement.timeoutId) clearTimeout(buttonElement.timeoutId);
                    buttonElement.timeoutId = setTimeout(() => {
                        buttonElement.textContent = originalText;
                        buttonElement.className = originalButtonClasses; 
                        buttonElement.timeoutId = null;
                    }, 1500);
                    return;
                } catch (err) {
                    console.error('Clipboard API failed: ', err);
                    showMessage('Could not copy using Clipboard API. Trying fallback.', true, 3000);
                }
            }

            try {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed"; textArea.style.left = "-9999px"; textArea.style.top = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus(); textArea.select();
                const successful = document.execCommand('copy');
                document.body.removeChild(textArea);

                if (successful) {
                    if (buttonElement.timeoutId) clearTimeout(buttonElement.timeoutId);
                    buttonElement.timeoutId = setTimeout(() => {
                        buttonElement.textContent = originalText;
                        buttonElement.className = originalButtonClasses; 
                        buttonElement.timeoutId = null;
                    }, 1500);
                    showMessage('Text copied (using fallback).');
                } else {
                    throw new Error('Fallback copy command failed.');
                }
            } catch (err) {
                console.error('Fallback copy failed: ', err);
                showMessage('Failed to copy text. Clipboard access might be blocked.', true, 4000);
                buttonElement.textContent = originalText;
                buttonElement.className = originalButtonClasses; 
            }
        }

        function extractValue(text, key) {
            const keyIndex = text.indexOf(key);
            if (keyIndex === -1) return null;
            let valueStartIndex = keyIndex + key.length;
            const potentialNextKeys = ["SKU:", "Font Style:", "Your custom text:", "Text Color:", "Text Outline Color:", "Size:"];
            const linesToIgnorePatterns = [
                /^Customizations:/i,
                /^Surface 1:/i,
                /^(?:Please\s+)?ignore\s+this\s+color(?:\s+and(?:\s+select(?:\s+(?:fron|front))?)?)?$/i
            ];
            let earliestNextKeyIndex = text.length;
            for (const nextKey of potentialNextKeys) {
                const currentNextKeyIndex = text.indexOf(nextKey, valueStartIndex);
                if (currentNextKeyIndex !== -1) {
                    const lineStartIndex = text.lastIndexOf('\n', currentNextKeyIndex) + 1;
                    if (text.substring(lineStartIndex, currentNextKeyIndex).trim() === '') {
                        earliestNextKeyIndex = Math.min(earliestNextKeyIndex, lineStartIndex);
                    }
                }
            }
            let rawValueBlock = text.substring(valueStartIndex, earliestNextKeyIndex);
            const valueLines = rawValueBlock.split('\n');
            const filteredLines = valueLines.filter(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '') return false;
                for (const pattern of linesToIgnorePatterns) { 
                    if (pattern.test(trimmedLine)) return false; 
                }
                return true;
            });
            
            let finalValue;
            if (key === "Your custom text:") {
                finalValue = filteredLines.join(' ').trim();
            } else {
                finalValue = filteredLines.join(' ').replace(/\s+/g, ' ').trim();
            }

            if (key === "Font Style:" && finalValue) {
                const trailingIgnorePattern = /\s+(?:please\s+)?ignore\s+this\s+color(?:.*)?$/i;
                finalValue = finalValue.replace(trailingIgnorePattern, '').trim();
            }
            
            return finalValue || null;
        }

        function extractHexCode(text) {
            if (!text) return null;
            const hexRegex = /#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})\b/;
            const match = text.match(hexRegex);
            return match ? match[0] : null;
        }

        function parseColorValue(colorValue) {
            if (!colorValue) return { descriptive: null, hex: null };
            const ignorePattern = /^(?:Please\s+)?ignore\s+this\s+color(?:\s+and(?:\s+select(?:\s+(?:fron|front))?)?)?.*$/i;
            let cleanedValue = colorValue.replace(ignorePattern, '').trim();
            
            const hex = extractHexCode(cleanedValue);
            let descriptive = cleanedValue;
            if (hex) {
                const hexIndex = descriptive.indexOf(hex);
                if (hexIndex !== -1) {
                    let startIndex = hexIndex;
                    while(startIndex > 0 && /[\s(]/.test(descriptive[startIndex-1])) startIndex--;
                    let endIndex = hexIndex + hex.length;
                    while(endIndex < descriptive.length && /[\s)]/.test(descriptive[endIndex])) endIndex++;
                    descriptive = descriptive.substring(0, startIndex) + descriptive.substring(endIndex);
                }
            }
            descriptive = descriptive.replace(/\s+/g, ' ').trim();
            return { descriptive: descriptive || null, hex: hex };
        }

        function createOutputRow(label, value, copyValue = null, needsReview = false) {
            if (value === null || value === undefined || String(value).trim() === '') return null;
            const finalCopyValue = (copyValue !== null && copyValue !== undefined) ? String(copyValue) : String(value);
            const displayValue = String(value);
            const div = document.createElement('div');
            div.className = 'output-item border-b border-slate-700';
            const labelSpan = document.createElement('span');
            labelSpan.className = 'output-label text-slate-400';
            labelSpan.textContent = label + ':';
            div.appendChild(labelSpan);
            const valueSpan = document.createElement('span');
            valueSpan.className = 'output-value text-slate-100';
            if (needsReview) {
                valueSpan.classList.add('needs-review');
            }
            valueSpan.textContent = displayValue;
            div.appendChild(valueSpan);
            const copyButton = document.createElement('button');
            copyButton.textContent = 'Copy';
            copyButton.className = 'copy-btn bg-slate-600 text-slate-200 hover:bg-slate-500';
            copyButton.onclick = () => copyToClipboard(finalCopyValue, copyButton);
            div.appendChild(copyButton);
            return div;
        }
        
        function cleanColorNameForFilename(colorName) {
            if (!colorName) return "";
            let cleaned = colorName.replace(/\s*\([^)]*\)\s*/g, '');
            cleaned = cleaned.replace(/#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})\b/gi, '');
            cleaned = cleaned.replace(/[^a-zA-Z0-9\s-]/g, '');
            cleaned = cleaned.replace(/\s+/g, ' ').trim();
            return cleaned;
        }

        function formatSizeForDisplayAndFilename(rawSizeString) {
            if (!rawSizeString) return { display: null, filenamePart: "" };

            let cleanedString = rawSizeString.replace(/Option to Add Complimentary Free Squeegee/gi, "").trim();
            
            const dimensions = [];
            const regex = /(\d+\.?\d*)\s*("|\u201D|inch(?:es)?)\s*(?:\(\s*(height|length|width|h|l|w)\s*\))?/gi;
            let match;

            while ((match = regex.exec(cleanedString)) !== null) {
                const value = match[1];
                let type = null;
                if (match[3]) {
                    const typeStr = match[3].toLowerCase();
                    if (typeStr.startsWith('l')) type = 'L';
                    else if (typeStr.startsWith('h')) type = 'H';
                    else if (typeStr.startsWith('w')) type = 'W';
                }
                dimensions.push({ value, unit: "INCH", type });
            }
            
            let lengthDim = dimensions.find(d => d.type === 'L');
            let heightDim = dimensions.find(d => d.type === 'H');
            let widthDim = dimensions.find(d => d.type === 'W');

            const displayParts = [];
            if (lengthDim) {
                displayParts.push(`${lengthDim.value} ${lengthDim.unit} ${lengthDim.type}`);
            }
            if (widthDim) {
                displayParts.push(`${widthDim.value} ${widthDim.unit} ${widthDim.type}`);
            }
            if (heightDim) {
                displayParts.push(`${heightDim.value} ${heightDim.unit} ${heightDim.type}`);
            }

            if (displayParts.length > 0) {
                const finalDisplay = displayParts.join(' ');
                return {
                    display: finalDisplay,
                    filenamePart: finalDisplay 
                };
            } else {
                let fallbackDisplay = cleanedString;
                fallbackDisplay = fallbackDisplay.replace(/\bINCHES\b/gi, 'INCH').replace(/\s*("|\u201D)\s*/g, ' INCH ').trim();
                
                let fallbackFilenamePart = cleanedString;
                fallbackFilenamePart = fallbackFilenamePart.replace(/\bLONG\b/gi, 'L');
                fallbackFilenamePart = fallbackFilenamePart.replace(/\bHEIGHT\b/gi, 'H');
                fallbackFilenamePart = fallbackFilenamePart.replace(/\bINCHES\b/gi, 'INCH');
                fallbackFilenamePart = fallbackFilenamePart.replace(/\s*("|\u201D)\s*/g, 'INCH'); 
                
                return { display: fallbackDisplay.trim() || null, filenamePart: fallbackFilenamePart.trim() || "" };
            }
        }

        function sanitizeForFilename(filenamePart) {
            if (!filenamePart) return "";
            return filenamePart.replace(/[<>:"/\\|?*\x00-\x1F]/g, '');
        }


        function processInputText(inputText) {
            if (!inputText || !inputText.trim()) {
                showMessage('Input text is empty after OCR or initial input.', true);
                outputSection.classList.add('hidden');
                return;
            }
            extractedInfoDiv.innerHTML = '';
            filenameOutputDiv.textContent = '';
            filenameOutputDiv.classList.remove('text-red-400', 'italic');
            outputSection.classList.add('hidden');
            const keys = { sku: "SKU:", fontStyle: "Font Style:", customText: "Your custom text:", textColorFull: "Text Color:", outlineColorFull: "Text Outline Color:", size: "Size:" };
            const rawValues = {};
            let missingKeys = [];
            for (const prop in keys) {
                rawValues[prop] = extractValue(inputText, keys[prop]);
                if (rawValues[prop] === null) missingKeys.push(keys[prop]);
            }
            const textColorParsed = parseColorValue(rawValues.textColorFull);
            const outlineColorParsed = parseColorValue(rawValues.outlineColorFull);
            
            let displaySize = null;
            let filenameSizeForPart = "";
            if (rawValues.size) {
                const parsedSizeInfo = formatSizeForDisplayAndFilename(rawValues.size);
                displaySize = parsedSizeInfo.display;
                filenameSizeForPart = parsedSizeInfo.filenamePart;

                if (filenameSizeForPart) {
                    filenameSizeForPart = filenameSizeForPart.replace(/\bLONG\b/gi, 'L').replace(/\bHEIGHT\b/gi, 'H');
                }
            }

            const finalValues = { 
                sku: rawValues.sku, 
                fontStyle: rawValues.fontStyle, 
                customText: rawValues.customText, 
                textColorDescriptive: textColorParsed.descriptive, 
                textColorHex: textColorParsed.hex, 
                outlineColorDescriptive: outlineColorParsed.descriptive, 
                outlineColorHex: outlineColorParsed.hex, 
                size: displaySize
            };

            let hasOutput = false;
            let customTextNeedsReview = false;
            if (finalValues.customText) {
                const spacedCapsRegex = /(?:\b[A-Z]\s){1,}[A-Z]\b/;
                if (spacedCapsRegex.test(finalValues.customText)) {
                    customTextNeedsReview = true;
                }
            }

            function addRow(label, value, copyValue = null, needsReview = false) {
                const row = createOutputRow(label, value, copyValue, needsReview);
                if (row) { extractedInfoDiv.appendChild(row); hasOutput = true; }
            }
            addRow('SKU', finalValues.sku); 
            addRow('Font Style', finalValues.fontStyle); 
            addRow('Your custom text', finalValues.customText, null, customTextNeedsReview); 
            addRow('Text Color', cleanColorNameForFilename(finalValues.textColorDescriptive)); 
            addRow('Text Hex Code', finalValues.textColorHex); 
            addRow('Text Outline Color', cleanColorNameForFilename(finalValues.outlineColorDescriptive)); 
            addRow('Text Outline Hex Code', finalValues.outlineColorHex); 
            addRow('Size', finalValues.size);
            
            if (!hasOutput && missingKeys.length === Object.keys(keys).length) {
                const noDataMsg = document.createElement('p');
                noDataMsg.textContent = 'No relevant information could be extracted.';
                noDataMsg.className = 'text-slate-400 italic p-2';
                extractedInfoDiv.appendChild(noDataMsg);
            } else if (!hasOutput) {
                const noDataMsg = document.createElement('p');
                noDataMsg.textContent = 'No displayable information found after processing.';
                noDataMsg.className = 'text-slate-400 italic p-2';
                extractedInfoDiv.appendChild(noDataMsg);
            }
            
            let customTextPart = finalValues.customText || "NoText";
            let tcFilenamePart = cleanColorNameForFilename(finalValues.textColorDescriptive);
            let tocFilenamePart = cleanColorNameForFilename(finalValues.outlineColorDescriptive);
            let sizeForFilename = filenameSizeForPart || "";
            let skuForFilename = finalValues.sku || "NoSKU";
            
            const tcPart = tcFilenamePart ? `(TC-${tcFilenamePart})` : "";
            const tocPart = tocFilenamePart ? `(TOC-${tocFilenamePart})` : "";
            const sizePart = sizeForFilename ? `(S-${sizeForFilename})` : "";
            const skuPart = `(${skuForFilename})`;

            let assembledFilename = `${customTextPart}${tcPart}${tocPart}${sizePart}${skuPart}`;
            generatedFilename = sanitizeForFilename(assembledFilename);

            filenameOutputDiv.textContent = generatedFilename;
            filenameOutputDiv.classList.remove('text-red-400');
            filenameOutputDiv.classList.add('text-slate-200');
            
            if (hasOutput || filenameOutputDiv.textContent.trim() !== "") {
                outputSection.classList.remove('hidden');
                if (missingKeys.length > 0) showMessage(`Data processed. Some fields might be missing: ${missingKeys.join(', ')}`, false, 4000);
                else showMessage('Data processed successfully!');
                outputSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                hasProcessedOnce = true;
            } else {
                showMessage('No data to display after processing.', true);
            }
        }

        function handleFileSelect(file) {
            if (file && file.type.startsWith('image/')) {
                if (hasProcessedOnce) {
                    resetForm();
                }
                selectedFile = file; 
                fileNameSpan.textContent = file.name; 
                dataInput.value = '';
                imageInput.files = createFileList(file);
                if (!submitButton.disabled) { 
                    submitButton.click();
                }
            } else { 
                showMessage('Please select or drop an image file.', true); 
            }
        }

        function createFileList(file) {
            const dataTransfer = new DataTransfer(); dataTransfer.items.add(file); return dataTransfer.files;
        }

        function resetForm() {
            dataInput.value = ''; outputSection.classList.add('hidden'); extractedInfoDiv.innerHTML = '';
            filenameOutputDiv.textContent = '';
            filenameOutputDiv.classList.remove('text-red-400', 'italic');
            filenameOutputDiv.classList.add('text-slate-200');
            imageInput.value = ''; selectedFile = null; fileNameSpan.textContent = 'No file chosen';
            showMessage('Form reset.');
            hasProcessedOnce = false;
        }

        pasteButton.addEventListener('click', async () => {
            if (navigator.clipboard && navigator.clipboard.readText && window.isSecureContext) {
                try {
                    const text = await navigator.clipboard.readText();
                    dataInput.value = text; imageInput.value = ''; selectedFile = null; fileNameSpan.textContent = 'No file chosen';
                    showMessage('Text pasted successfully!');
                    hasProcessedOnce = false; 
                } catch (err) { console.error('Clipboard read failed: ', err); showMessage('Failed to paste. Check permissions or HTTPS.', true, 4000); }
            } else { showMessage('Clipboard paste not available/supported (requires HTTPS).', true, 4000); }
        });

        imageInput.addEventListener('change', (event) => handleFileSelect(event.target.files[0]));

        dropZone.addEventListener('dragover', (event) => {
            event.preventDefault(); 
            event.stopPropagation(); 
            dropZone.classList.add('dragover', 'bg-blue-900/60', 'border-blue-500');
            dropZone.classList.remove('bg-slate-700', 'border-slate-600');
        });
        dropZone.addEventListener('dragleave', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropZone.classList.remove('dragover', 'bg-blue-900/60', 'border-blue-500');
            dropZone.classList.add('bg-slate-700', 'border-slate-600');
        });
        dropZone.addEventListener('drop', (event) => {
            event.preventDefault();
            event.stopPropagation(); 
            dropZone.classList.remove('dragover', 'bg-blue-900/60', 'border-blue-500');
            dropZone.classList.add('bg-slate-700', 'border-slate-600');
            
            if (event.dataTransfer?.items) {
                if (event.dataTransfer.items.length === 1 && event.dataTransfer.items[0].kind === 'file') {
                    const file = event.dataTransfer.items[0].getAsFile();
                    if (file.type.startsWith('image/')) {
                        handleFileSelect(file);
                    } else {
                        showMessage('Please drop an image file.', true);
                    }
                } else if (event.dataTransfer.items.length > 1) showMessage('Please drop only one image file.', true);
                else showMessage('Please drop an image file.', true);
            } else if (event.dataTransfer?.files) { 
                if (event.dataTransfer.files.length === 1 && event.dataTransfer.files[0].type.startsWith('image/')) {
                    handleFileSelect(event.dataTransfer.files[0]);
                } else if (event.dataTransfer.files.length > 1) showMessage('Please drop only one image file.', true);
                else showMessage('Please drop an image file.', true);
            }
        });

        window.addEventListener('dragover', (event) => {
            event.preventDefault(); 
        }, false);

        window.addEventListener('drop', (event) => {
            event.preventDefault(); 
            
            if (event.dataTransfer?.items) {
                if (event.dataTransfer.items.length === 1 && event.dataTransfer.items[0].kind === 'file') {
                    const file = event.dataTransfer.items[0].getAsFile();
                     if (file.type.startsWith('image/')) {
                        handleFileSelect(file);
                    }
                }
            } else if (event.dataTransfer?.files) { 
                if (event.dataTransfer.files.length === 1 && event.dataTransfer.files[0].type.startsWith('image/')) {
                    handleFileSelect(event.dataTransfer.files[0]);
                }
            }
             dropZone.classList.remove('dragover', 'bg-blue-900/60', 'border-blue-500');
             dropZone.classList.add('bg-slate-700', 'border-slate-600');
        }, false);

        submitButton.addEventListener('click', async () => {
            if (submitButton.disabled) return;
            const inputText = dataInput.value; const imageFile = selectedFile;
            if (inputText.trim()) {
                processInputText(inputText);
            } else if (imageFile) {
                showMessage('Processing image... this may take a moment.', false, 10000);
                showProcessingState(true);
                try {
                    const { data: { text } } = await Tesseract.recognize(
                        imageFile, 
                        'eng',
                        {
                            tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE, 
                            preserve_interword_spaces: '1', 
                        }
                    );
                    console.log("OCR Result:", text); 
                    processInputText(text);
                } catch (error) { 
                    console.error("OCR Error:", error); 
                    showMessage(`Error during image processing: ${error.message || 'Unknown error'}`, true, 5000); 
                    outputSection.classList.add('hidden'); 
                }
                finally { 
                    showProcessingState(false); 
                }
            } else { 
                showMessage('Please paste text or upload an image first.', true); 
                outputSection.classList.add('hidden'); 
            }
        });

        copyFilenameButton.addEventListener('click', () => {
            const filenameToCopy = filenameOutputDiv.textContent;
            if (!filenameOutputDiv.classList.contains('text-red-400') && filenameToCopy) {
                copyToClipboard(filenameToCopy, copyFilenameButton);
            } else { showMessage('Cannot copy filename error message or empty filename.', true); }
        });

        pageTitle.addEventListener('click', resetForm);

        document.addEventListener('keydown', (event) => {
            const activeElement = document.activeElement;
            const targetTagName = activeElement ? activeElement.tagName.toLowerCase() : '';
            const isTypingArea = targetTagName === 'textarea' || targetTagName === 'input' || (activeElement && activeElement.isContentEditable);

            if (event.key === 'Enter' && !isTypingArea && targetTagName !== 'button' && !submitButton.disabled) {
                event.preventDefault(); submitButton.click();
            } else if (event.key === 'Backspace' && !isTypingArea) {
                event.preventDefault(); resetForm();
            }
        });
    </script>
</body>
</html>
